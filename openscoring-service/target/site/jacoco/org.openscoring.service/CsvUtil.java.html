<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CsvUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Openscoring Service</a> &gt; <a href="index.source.html" class="el_package">org.openscoring.service</a> &gt; <span class="el_source">CsvUtil.java</span></div><h1>CsvUtil.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2013 Villu Ruusmann
 *
 * This file is part of Openscoring
 *
 * Openscoring is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Openscoring is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with Openscoring.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.openscoring.service;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openscoring.common.EvaluationRequest;
import org.openscoring.common.EvaluationResponse;
import org.supercsv.encoder.DefaultCsvEncoder;
import org.supercsv.io.CsvListReader;
import org.supercsv.io.CsvMapReader;
import org.supercsv.io.CsvMapWriter;
import org.supercsv.prefs.CsvPreference;

public class CsvUtil {

<span class="nc" id="L41">	private CsvUtil(){</span>
<span class="nc" id="L42">	}</span>

	static
	public CsvPreference getFormat(String delimiterChar, String quoteChar){
<span class="fc" id="L46">		char delimiter = ',';</span>
<span class="fc" id="L47">		char quote = '\&quot;';</span>

<span class="pc bpc" id="L49" title="1 of 2 branches missed.">		if(delimiterChar != null){</span>
<span class="fc" id="L50">			delimiterChar = decodeDelimiter(delimiterChar);</span>

<span class="pc bpc" id="L52" title="1 of 2 branches missed.">			if(delimiterChar.length() != 1){</span>
<span class="nc" id="L53">				throw new IllegalArgumentException(&quot;Invalid CSV delimiter character: \&quot;&quot; + delimiterChar + &quot;\&quot;&quot;);</span>
			}

<span class="fc" id="L56">			delimiter = delimiterChar.charAt(0);</span>
		} // End if

<span class="pc bpc" id="L59" title="1 of 2 branches missed.">		if(quoteChar != null){</span>
<span class="fc" id="L60">			quoteChar = decodeQuote(quoteChar);</span>

<span class="pc bpc" id="L62" title="1 of 2 branches missed.">			if(quoteChar.length() != 1){</span>
<span class="nc" id="L63">				throw new IllegalArgumentException(&quot;Invalid CSV quote character: \&quot;&quot; + quoteChar + &quot;\&quot;&quot;);</span>
			}

<span class="fc" id="L66">			quote = quoteChar.charAt(0);</span>
		}

<span class="fc" id="L69">		CsvPreference format = createFormat(delimiter, quote);</span>

<span class="fc" id="L71">		return format;</span>
	}

	static
	public CsvPreference getFormat(BufferedReader reader) throws IOException {
<span class="fc" id="L76">		reader.mark(10 * 1024);</span>

<span class="pc bpc" id="L78" title="1 of 2 branches missed.">		for(int i = 0; i &lt; CsvUtil.DELIMITERS.length; i++){</span>
<span class="fc" id="L79">			char delimiter = CsvUtil.DELIMITERS[i];</span>

			try {
<span class="fc" id="L82">				CsvPreference format = createFormat(delimiter, '\&quot;');</span>

<span class="fc bfc" id="L84" title="All 2 branches covered.">				if(checkFormat(reader, format)){</span>
<span class="fc" id="L85">					return format;</span>
				}
			} finally {
<span class="pc" id="L88">				reader.reset();</span>
<span class="fc" id="L89">			}</span>
		}

<span class="nc" id="L92">		throw new IOException(&quot;Unrecognized CSV format&quot;);</span>
	}

	static
	private CsvPreference createFormat(char delimiter, char quote){
<span class="fc" id="L97">		CsvPreference.Builder builder = new CsvPreference.Builder(quote, delimiter, &quot;\n&quot;);</span>
<span class="fc" id="L98">		builder.useEncoder(new DefaultCsvEncoder());</span>

<span class="fc" id="L100">		return builder.build();</span>
	}

	static
	private boolean checkFormat(BufferedReader reader, CsvPreference format) throws IOException {
<span class="fc" id="L105">		CsvListReader parser = new CsvListReader(reader, format){</span>

			@Override
			public void close(){
<span class="fc" id="L109">			}</span>
		};

<span class="fc" id="L112">		int columns = 0;</span>

		// Check the header line and the first ten lines
<span class="fc bfc" id="L115" title="All 2 branches covered.">		for(int line = 0; line &lt; (1 + 10); line++){</span>
<span class="fc" id="L116">			List&lt;String&gt; row = parser.read();</span>

<span class="fc bfc" id="L118" title="All 2 branches covered.">			if(row == null){</span>
<span class="fc" id="L119">				break;</span>
			}

<span class="fc" id="L122">			int rowColumns = row.size();</span>
<span class="pc bpc" id="L123" title="1 of 6 branches missed.">			if((rowColumns &gt; 1) &amp;&amp; (columns == 0 || columns == rowColumns)){</span>
<span class="fc" id="L124">				columns = rowColumns;</span>
			} else

			{
<span class="fc" id="L128">				return false;</span>
			}
		}

<span class="fc" id="L132">		parser.close();</span>

<span class="pc bpc" id="L134" title="1 of 2 branches missed.">		return (columns &gt; 1);</span>
	}

	static
	public Table&lt;EvaluationRequest&gt; readTable(BufferedReader reader, CsvPreference format) throws IOException {
<span class="fc" id="L139">		Table&lt;EvaluationRequest&gt; table = new Table&lt;&gt;();</span>

<span class="fc" id="L141">		CsvMapReader parser = new CsvMapReader(reader, format);</span>

<span class="fc" id="L143">		String[] header = parser.getHeader(true);</span>

<span class="pc bpc" id="L145" title="1 of 4 branches missed.">		if(header.length &gt; 0 &amp;&amp; (&quot;id&quot;).equalsIgnoreCase(header[0])){</span>
<span class="fc" id="L146">			table.setId(header[0]);</span>
		}

<span class="fc" id="L149">		List&lt;EvaluationRequest&gt; requests = new ArrayList&lt;&gt;();</span>

		while(true){
<span class="fc" id="L152">			Map&lt;String, String&gt; arguments = parser.read(header);</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">			if(arguments == null){</span>
<span class="fc" id="L154">				break;</span>
			}

<span class="fc" id="L157">			String id = arguments.remove(table.getId());</span>

<span class="fc" id="L159">			EvaluationRequest request = new EvaluationRequest(id);</span>
<span class="fc" id="L160">			request.setArguments(arguments);</span>

<span class="fc" id="L162">			requests.add(request);</span>
<span class="fc" id="L163">		}</span>

<span class="fc" id="L165">		parser.close();</span>

<span class="fc" id="L167">		table.setRows(requests);</span>

<span class="fc" id="L169">		return table;</span>
	}

	static
	public void writeTable(BufferedWriter writer, CsvPreference format, Table&lt;EvaluationResponse&gt; table) throws IOException {
<span class="fc" id="L174">		CsvMapWriter formatter = new CsvMapWriter(writer, format);</span>

<span class="fc" id="L176">		String[] header = null;</span>

<span class="fc" id="L178">		List&lt;EvaluationResponse&gt; responses = table.getRows();</span>

<span class="fc bfc" id="L180" title="All 2 branches covered.">		for(EvaluationResponse response : responses){</span>
<span class="fc" id="L181">			Map&lt;String, ?&gt; result = response.getResult();</span>

<span class="fc" id="L183">			String id = response.getId();</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">			if(id != null){</span>
<span class="nc" id="L185">				result = join(Collections.&lt;String, String&gt;singletonMap(table.getId(), id), result);</span>
			} // End if

<span class="fc bfc" id="L188" title="All 2 branches covered.">			if(header == null){</span>
<span class="fc" id="L189">				Set&lt;String&gt; keys = result.keySet();</span>

<span class="fc" id="L191">				header = (keys).toArray(new String[keys.size()]);</span>

<span class="fc" id="L193">				formatter.writeHeader(header);</span>
			}

<span class="fc" id="L196">			formatter.write(result, header);</span>
<span class="fc" id="L197">		}</span>

<span class="fc" id="L199">		formatter.flush();</span>
<span class="fc" id="L200">		formatter.close();</span>
<span class="fc" id="L201">	}</span>

	static
	private String decodeDelimiter(String delimiterChar){

<span class="pc bpc" id="L206" title="1 of 2 branches missed.">		if((&quot;\\t&quot;).equals(delimiterChar)){</span>
<span class="fc" id="L207">			return &quot;\t&quot;;</span>
		}

<span class="nc" id="L210">		return delimiterChar;</span>
	}

	static
	private String decodeQuote(String quoteChar){

<span class="pc bpc" id="L216" title="1 of 2 branches missed.">		if((&quot;\\'&quot;).equals(quoteChar)){</span>
<span class="nc" id="L217">			return &quot;\'&quot;;</span>
		} else

<span class="pc bpc" id="L220" title="1 of 2 branches missed.">		if((&quot;\\\&quot;&quot;).equals(quoteChar)){</span>
<span class="fc" id="L221">			return &quot;\&quot;&quot;;</span>
		}

<span class="nc" id="L224">		return quoteChar;</span>
	}

	static
	private Map&lt;String, ?&gt; join(Map&lt;String, ?&gt; left, Map&lt;String, ?&gt; right){
<span class="nc" id="L229">		Map&lt;String, Object&gt; result = new LinkedHashMap&lt;&gt;(left);</span>
<span class="nc" id="L230">		result.putAll(right);</span>

<span class="nc" id="L232">		return result;</span>
	}

	static
<span class="fc" id="L236">	public class Table&lt;R&gt; {</span>

<span class="fc" id="L238">		private String id = null;</span>

<span class="fc" id="L240">		private List&lt;R&gt; rows = null;</span>


		public String getId(){
<span class="fc" id="L244">			return this.id;</span>
		}

		public void setId(String id){

<span class="pc bpc" id="L249" title="1 of 2 branches missed.">			if(this.id != null){</span>
<span class="nc" id="L250">				throw new IllegalStateException();</span>
			}

<span class="fc" id="L253">			this.id = id;</span>
<span class="fc" id="L254">		}</span>

		public List&lt;R&gt; getRows(){
<span class="fc" id="L257">			return this.rows;</span>
		}

		public void setRows(List&lt;R&gt; rows){
<span class="fc" id="L261">			this.rows = rows;</span>
<span class="fc" id="L262">		}</span>
	}

<span class="fc" id="L265">	private static final char[] DELIMITERS = {',', ';', '\t'};</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>