<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ModelResource.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Openscoring Service</a> &gt; <a href="index.source.html" class="el_package">org.openscoring.service</a> &gt; <span class="el_source">ModelResource.java</span></div><h1>ModelResource.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2013 Villu Ruusmann
 *
 * This file is part of Openscoring
 *
 * Openscoring is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Openscoring is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with Openscoring.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.openscoring.service;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.URI;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.security.PermitAll;
import javax.annotation.security.RolesAllowed;
import javax.inject.Inject;
import javax.ws.rs.BadRequestException;
import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.GET;
import javax.ws.rs.HeaderParam;
import javax.ws.rs.InternalServerErrorException;
import javax.ws.rs.NotFoundException;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.StreamingOutput;
import javax.ws.rs.core.UriBuilder;
import javax.ws.rs.core.UriInfo;
import javax.xml.bind.JAXBException;

import com.codahale.metrics.Counter;
import com.codahale.metrics.Metric;
import com.codahale.metrics.MetricFilter;
import com.codahale.metrics.MetricRegistry;
import com.codahale.metrics.Timer;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ListMultimap;
import org.dmg.pmml.FieldName;
import org.glassfish.jersey.media.multipart.FormDataParam;
import org.jpmml.evaluator.EvaluationException;
import org.jpmml.evaluator.Evaluator;
import org.jpmml.evaluator.EvaluatorUtil;
import org.jpmml.evaluator.FieldValue;
import org.jpmml.evaluator.HasGroupFields;
import org.jpmml.evaluator.InputField;
import org.jpmml.evaluator.ModelEvaluator;
import org.openscoring.common.BatchEvaluationRequest;
import org.openscoring.common.BatchEvaluationResponse;
import org.openscoring.common.BatchModelResponse;
import org.openscoring.common.EvaluationRequest;
import org.openscoring.common.EvaluationResponse;
import org.openscoring.common.ModelResponse;
import org.openscoring.common.SimpleResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.supercsv.prefs.CsvPreference;

@Path(&quot;model&quot;)
@PermitAll
public class ModelResource {

<span class="fc" id="L95">	@Context</span>
	private UriInfo uriInfo = null;

<span class="fc" id="L98">	private ModelRegistry modelRegistry = null;</span>

<span class="fc" id="L100">	private MetricRegistry metricRegistry = null;</span>


	@Inject
<span class="fc" id="L104">	public ModelResource(ModelRegistry modelRegistry, MetricRegistry metricRegistry){</span>
<span class="fc" id="L105">		this.modelRegistry = modelRegistry;</span>
<span class="fc" id="L106">		this.metricRegistry = metricRegistry;</span>
<span class="fc" id="L107">	}</span>

	@GET
	@Produces(MediaType.APPLICATION_JSON)
	public BatchModelResponse queryBatch(){
<span class="nc" id="L112">		BatchModelResponse batchResponse = new BatchModelResponse();</span>

<span class="nc" id="L114">		List&lt;ModelResponse&gt; responses = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L116">		Collection&lt;Map.Entry&lt;String, Model&gt;&gt; entries = this.modelRegistry.entries();</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">		for(Map.Entry&lt;String, Model&gt; entry : entries){</span>
<span class="nc" id="L118">			ModelResponse response = createModelResponse(entry.getKey(), entry.getValue(), false);</span>

<span class="nc" id="L120">			responses.add(response);</span>
<span class="nc" id="L121">		}</span>

<span class="nc" id="L123">		Comparator&lt;ModelResponse&gt; comparator = new Comparator&lt;ModelResponse&gt;(){</span>

			@Override
			public int compare(ModelResponse left, ModelResponse right){
<span class="nc" id="L127">				return (left.getId()).compareToIgnoreCase(right.getId());</span>
			}
		};
<span class="nc" id="L130">		Collections.sort(responses, comparator);</span>

<span class="nc" id="L132">		batchResponse.setResponses(responses);</span>

<span class="nc" id="L134">		return batchResponse;</span>
	}

	@GET
	@Path(&quot;{id:&quot; + ModelRegistry.ID_REGEX + &quot;}&quot;)
	@Produces(MediaType.APPLICATION_JSON)
	public ModelResponse query(@PathParam(&quot;id&quot;) String id){
<span class="nc" id="L141">		Model model = this.modelRegistry.get(id);</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">		if(model == null){</span>
<span class="nc" id="L143">			throw new NotFoundException(&quot;Model \&quot;&quot; + id + &quot;\&quot; not found&quot;);</span>
		}

<span class="nc" id="L146">		return createModelResponse(id, model, true);</span>
	}

	@PUT
	@Path(&quot;{id:&quot; + ModelRegistry.ID_REGEX + &quot;}&quot;)
	@RolesAllowed (
		value = {&quot;admin&quot;}
	)
	@Consumes({MediaType.APPLICATION_XML, MediaType.TEXT_XML})
	@Produces(MediaType.APPLICATION_JSON)
	public Response deploy(@PathParam(&quot;id&quot;) String id, InputStream is){
<span class="fc" id="L157">		return doDeploy(id, is);</span>
	}

	@POST
	@RolesAllowed (
		value = {&quot;admin&quot;}
	)
	@Consumes(MediaType.MULTIPART_FORM_DATA)
	@Produces(MediaType.APPLICATION_JSON)
	public Response deployForm(@FormDataParam(&quot;id&quot;) String id, @FormDataParam(&quot;pmml&quot;) InputStream is){

<span class="pc bpc" id="L168" title="1 of 2 branches missed.">		if(!ModelRegistry.validateId(id)){</span>
<span class="nc" id="L169">			throw new BadRequestException(&quot;Invalid identifier&quot;);</span>
		}

<span class="fc" id="L172">		return doDeploy(id, is);</span>
	}

	private Response doDeploy(String id, InputStream is){
		Model model;

		try {
<span class="fc" id="L179">			model = this.modelRegistry.load(is);</span>
<span class="nc" id="L180">		} catch(Exception e){</span>
<span class="nc" id="L181">			logger.error(&quot;Failed to load PMML document&quot;, e);</span>

<span class="nc" id="L183">			throw new BadRequestException(e);</span>
<span class="fc" id="L184">		}</span>

		boolean success;

<span class="fc" id="L188">		Model oldModel = this.modelRegistry.get(id);</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">		if(oldModel != null){</span>
<span class="nc" id="L190">			success = this.modelRegistry.replace(id, oldModel, model);</span>
		} else

		{
<span class="fc" id="L194">			success = this.modelRegistry.put(id, model);</span>
		} // End if

<span class="pc bpc" id="L197" title="1 of 2 branches missed.">		if(!success){</span>
<span class="nc" id="L198">			throw new InternalServerErrorException(&quot;Concurrent modification&quot;);</span>
		}

<span class="fc" id="L201">		ModelResponse entity = createModelResponse(id, model, true);</span>

<span class="pc bpc" id="L203" title="1 of 2 branches missed.">		if(oldModel != null){</span>
<span class="nc" id="L204">			return (Response.ok().entity(entity)).build();</span>
		} else

		{
<span class="fc" id="L208">			UriBuilder uriBuilder = (this.uriInfo.getBaseUriBuilder()).path(ModelResource.class).path(id);</span>

<span class="fc" id="L210">			URI uri = uriBuilder.build();</span>

<span class="fc" id="L212">			return (Response.created(uri).entity(entity)).build();</span>
		}
	}

	@GET
	@Path(&quot;{id:&quot; + ModelRegistry.ID_REGEX + &quot;}/pmml&quot;)
	@RolesAllowed (
		value = {&quot;admin&quot;}
	)
	@Produces({MediaType.APPLICATION_JSON, MediaType.TEXT_XML})
	public Response download(@PathParam(&quot;id&quot;) String id){
		final
<span class="fc" id="L224">		Model model = this.modelRegistry.get(id, true);</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">		if(model == null){</span>
<span class="nc" id="L226">			throw new NotFoundException(&quot;Model \&quot;&quot; + id + &quot;\&quot; not found&quot;);</span>
		}

<span class="fc" id="L229">		StreamingOutput entity = new StreamingOutput(){</span>

			@Override
			public void write(OutputStream os) throws IOException {
<span class="fc" id="L233">				BufferedOutputStream bufferedOs = new BufferedOutputStream(os){</span>

					@Override
					public void close() throws IOException {
<span class="fc" id="L237">						flush();</span>

						// The closing of the underlying java.io.OutputStream is handled elsewhere
<span class="fc" id="L240">					}</span>
				};

				try {
<span class="fc" id="L244">					ModelResource.this.modelRegistry.store(model, bufferedOs);</span>
<span class="nc" id="L245">				} catch(JAXBException je){</span>
<span class="nc" id="L246">					throw new InternalServerErrorException(je);</span>
				} finally {
<span class="pc" id="L248">					bufferedOs.close();</span>
<span class="fc" id="L249">				}</span>
<span class="fc" id="L250">			}</span>
		};

<span class="fc" id="L253">		return (Response.ok().entity(entity))</span>
<span class="fc" id="L254">			.type(MediaType.APPLICATION_XML_TYPE.withCharset(ModelResource.CHARSET_UTF8.name()))</span>
<span class="fc" id="L255">			.header(HttpHeaders.CONTENT_DISPOSITION, &quot;attachment; filename=&quot; + id + &quot;.pmml.xml&quot;) // XXX</span>
<span class="fc" id="L256">			.build();</span>
	}

	@POST
	@Path(&quot;{id:&quot; + ModelRegistry.ID_REGEX + &quot;}&quot;)
	@Consumes(MediaType.APPLICATION_JSON)
	@Produces(MediaType.APPLICATION_JSON)
	public EvaluationResponse evaluate(@PathParam(&quot;id&quot;) String id, EvaluationRequest request){
<span class="fc" id="L264">		List&lt;EvaluationRequest&gt; requests = Collections.singletonList(request);</span>

<span class="fc" id="L266">		List&lt;EvaluationResponse&gt; responses = doEvaluate(id, requests, true, &quot;evaluate&quot;);</span>

<span class="fc" id="L268">		return responses.get(0);</span>
	}

	@POST
	@Path(&quot;{id: &quot; + ModelRegistry.ID_REGEX + &quot;}/batch&quot;)
	@Consumes(MediaType.APPLICATION_JSON)
	@Produces(MediaType.APPLICATION_JSON)
	public BatchEvaluationResponse evaluateBatch(@PathParam(&quot;id&quot;) String id, BatchEvaluationRequest request){
<span class="fc" id="L276">		BatchEvaluationResponse batchResponse = new BatchEvaluationResponse(request.getId());</span>

<span class="fc" id="L278">		List&lt;EvaluationRequest&gt; requests = request.getRequests();</span>

<span class="fc" id="L280">		List&lt;EvaluationResponse&gt; responses = doEvaluate(id, requests, false, &quot;evaluate.batch&quot;);</span>

<span class="fc" id="L282">		batchResponse.setResponses(responses);</span>

<span class="fc" id="L284">		return batchResponse;</span>
	}

	@POST
	@Path(&quot;{id:&quot; + ModelRegistry.ID_REGEX + &quot;}/csv&quot;)
	@Consumes(MediaType.TEXT_PLAIN)
	@Produces({MediaType.APPLICATION_JSON, MediaType.TEXT_PLAIN})
	public Response evaluateCsv(@PathParam(&quot;id&quot;) String id, @QueryParam(&quot;delimiterChar&quot;) String delimiterChar, @QueryParam(&quot;quoteChar&quot;) String quoteChar, @HeaderParam(HttpHeaders.CONTENT_TYPE) String contentType, InputStream is){
<span class="fc" id="L292">		com.google.common.net.MediaType mediaType = com.google.common.net.MediaType.parse(contentType);</span>

<span class="fc" id="L294">		Charset charset = (mediaType.charset()).or(ModelResource.CHARSET_UTF8);</span>

<span class="fc" id="L296">		return doEvaluateCsv(id, delimiterChar, quoteChar, charset, is);</span>
	}

	@POST
	@Path(&quot;{id:&quot; + ModelRegistry.ID_REGEX + &quot;}/csv&quot;)
	@Consumes(MediaType.MULTIPART_FORM_DATA)
	@Produces({MediaType.APPLICATION_JSON, MediaType.TEXT_PLAIN})
	public Response evaluateCsvForm(@PathParam(&quot;id&quot;) String id, @QueryParam(&quot;delimiterChar&quot;) String delimiterChar, @QueryParam(&quot;quoteChar&quot;) String quoteChar, @FormDataParam(&quot;csv&quot;) InputStream is){
<span class="fc" id="L304">		Charset charset = ModelResource.CHARSET_UTF8;</span>

<span class="fc" id="L306">		return doEvaluateCsv(id, delimiterChar, quoteChar, charset, is);</span>
	}

	private Response doEvaluateCsv(String id, String delimiterChar, String quoteChar, final Charset charset, InputStream is){
		final
		CsvPreference format;

		final
		CsvUtil.Table&lt;EvaluationRequest&gt; requestTable;

		try {
<span class="fc" id="L317">			BufferedReader reader = new BufferedReader(new InputStreamReader(is, charset)){</span>

				@Override
				public void close(){
					// The closing of the underlying java.io.InputStream is handled elsewhere
<span class="fc" id="L322">				}</span>
			};

			try {
<span class="fc bfc" id="L326" title="All 2 branches covered.">				if(delimiterChar != null){</span>
<span class="fc" id="L327">					format = CsvUtil.getFormat(delimiterChar, quoteChar);</span>
				} else

				{
<span class="fc" id="L331">					format = CsvUtil.getFormat(reader);</span>
				}

<span class="fc" id="L334">				requestTable = CsvUtil.readTable(reader, format);</span>
			} finally {
<span class="pc" id="L336">				reader.close();</span>
<span class="fc" id="L337">			}</span>
<span class="nc" id="L338">		} catch(Exception e){</span>
<span class="nc" id="L339">			logger.error(&quot;Failed to load CSV document&quot;, e);</span>

<span class="nc" id="L341">			throw new BadRequestException(e);</span>
<span class="fc" id="L342">		}</span>

<span class="fc" id="L344">		List&lt;EvaluationRequest&gt; requests = requestTable.getRows();</span>

<span class="fc" id="L346">		List&lt;EvaluationResponse&gt; responses = doEvaluate(id, requests, true, &quot;evaluate.csv&quot;);</span>

		final
<span class="fc" id="L349">		CsvUtil.Table&lt;EvaluationResponse&gt; responseTable = new CsvUtil.Table&lt;&gt;();</span>
<span class="fc" id="L350">		responseTable.setId(requestTable.getId());</span>
<span class="fc" id="L351">		responseTable.setRows(responses);</span>

<span class="fc" id="L353">		StreamingOutput entity = new StreamingOutput(){</span>

			@Override
			public void write(OutputStream os) throws IOException {
<span class="fc" id="L357">				BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, charset)){</span>

					@Override
					public void close() throws IOException {
<span class="fc" id="L361">						flush();</span>

						// The closing of the underlying java.io.OutputStream is handled elsewhere
<span class="fc" id="L364">					}</span>
				};

				try {
<span class="fc" id="L368">					CsvUtil.writeTable(writer, format, responseTable);</span>
				} finally {
<span class="pc" id="L370">					writer.close();</span>
<span class="fc" id="L371">				}</span>
<span class="fc" id="L372">			}</span>
		};

<span class="fc" id="L375">		return (Response.ok().entity(entity))</span>
<span class="fc" id="L376">			.type(MediaType.TEXT_PLAIN_TYPE.withCharset(charset.name()))</span>
<span class="fc" id="L377">			.header(HttpHeaders.CONTENT_DISPOSITION, &quot;attachment; filename=&quot; + id + &quot;.csv&quot;) // XXX</span>
<span class="fc" id="L378">			.build();</span>
	}

	@SuppressWarnings (
		value = &quot;resource&quot;
	)
	private List&lt;EvaluationResponse&gt; doEvaluate(String id, List&lt;EvaluationRequest&gt; requests, boolean allOrNothing, String method){
<span class="fc" id="L385">		Model model = this.modelRegistry.get(id, true);</span>
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">		if(model == null){</span>
<span class="nc" id="L387">			throw new NotFoundException(&quot;Model \&quot;&quot; + id + &quot;\&quot; not found&quot;);</span>
		}

<span class="fc" id="L390">		List&lt;EvaluationResponse&gt; responses = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L392">		Timer timer = this.metricRegistry.timer(createName(id, method));</span>

<span class="fc" id="L394">		Timer.Context context = timer.time();</span>

		try {
<span class="fc" id="L397">			ModelEvaluator&lt;?&gt; evaluator = model.getEvaluator();</span>

<span class="fc bfc" id="L399" title="All 2 branches covered.">			if(evaluator instanceof HasGroupFields){</span>
<span class="fc" id="L400">				HasGroupFields hasGroupFields = (HasGroupFields)evaluator;</span>

<span class="fc" id="L402">				List&lt;InputField&gt; groupFields = hasGroupFields.getGroupFields();</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">				if(groupFields.size() == 1){</span>
<span class="fc" id="L404">					InputField groupField = groupFields.get(0);</span>

<span class="fc" id="L406">					requests = aggregateRequests(groupField.getName(), requests);</span>
<span class="fc" id="L407">				} else</span>

<span class="nc bnc" id="L409" title="All 2 branches missed.">				if(groupFields.size() &gt; 1){</span>
<span class="nc" id="L410">					throw new EvaluationException(&quot;Too many group fields&quot;);</span>
				}
			}

<span class="fc bfc" id="L414" title="All 2 branches covered.">			for(EvaluationRequest request : requests){</span>
				EvaluationResponse response;

				try {
<span class="fc" id="L418">					response = evaluate(evaluator, request);</span>
<span class="fc" id="L419">				} catch(Exception e){</span>

<span class="pc bpc" id="L421" title="1 of 2 branches missed.">					if(allOrNothing){</span>
<span class="nc" id="L422">						throw e;</span>
					}

<span class="fc" id="L425">					response = new EvaluationResponse(request.getId());</span>
<span class="fc" id="L426">					response.setMessage(e.toString());</span>
<span class="fc" id="L427">				}</span>

<span class="fc" id="L429">				responses.add(response);</span>
<span class="fc" id="L430">			}</span>
<span class="nc" id="L431">		} catch(Exception e){</span>
<span class="nc" id="L432">			logger.error(&quot;Failed to evaluate&quot;, e);</span>

<span class="nc" id="L434">			throw new BadRequestException(e);</span>
<span class="fc" id="L435">		}</span>

<span class="fc" id="L437">		context.stop();</span>

<span class="fc" id="L439">		Counter counter = this.metricRegistry.counter(createName(id, &quot;records&quot;));</span>

<span class="fc" id="L441">		counter.inc(responses.size());</span>

<span class="fc" id="L443">		return responses;</span>
	}

	@DELETE
	@Path(&quot;{id:&quot; + ModelRegistry.ID_REGEX + &quot;}&quot;)
	@RolesAllowed (
		value = {&quot;admin&quot;}
	)
	@Produces(MediaType.APPLICATION_JSON)
	public SimpleResponse undeploy(@PathParam(&quot;id&quot;) String id){
<span class="fc" id="L453">		Model model = this.modelRegistry.get(id);</span>
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">		if(model == null){</span>
<span class="nc" id="L455">			throw new NotFoundException(&quot;Model \&quot;&quot; + id + &quot;\&quot; not found&quot;);</span>
		}

<span class="fc" id="L458">		boolean success = this.modelRegistry.remove(id, model);</span>
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">		if(!success){</span>
<span class="nc" id="L460">			throw new InternalServerErrorException(&quot;Concurrent modification&quot;);</span>
		}

		final
<span class="fc" id="L464">		String prefix = createNamePrefix(id);</span>

<span class="fc" id="L466">		MetricFilter filter = new MetricFilter(){</span>

			@Override
			public boolean matches(String name, Metric metric){
<span class="fc" id="L470">				return name.startsWith(prefix);</span>
			}
		};

<span class="fc" id="L474">		this.metricRegistry.removeMatching(filter);</span>

<span class="fc" id="L476">		SimpleResponse response = new SimpleResponse();</span>

<span class="fc" id="L478">		return response;</span>
	}

	static
	protected String createName(String... strings){
<span class="fc" id="L483">		return MetricRegistry.name(ModelResource.class, strings);</span>
	}

	static
	protected String createNamePrefix(String... strings){
<span class="fc" id="L488">		return createName(strings) + &quot;.&quot;;</span>
	}

	static
	protected List&lt;EvaluationRequest&gt; aggregateRequests(FieldName groupName, List&lt;EvaluationRequest&gt; requests){
<span class="fc" id="L493">		Map&lt;Object, ListMultimap&lt;String, Object&gt;&gt; groupedArguments = new LinkedHashMap&lt;&gt;();</span>

<span class="fc" id="L495">		String key = groupName.getValue();</span>

<span class="fc bfc" id="L497" title="All 2 branches covered.">		for(EvaluationRequest request : requests){</span>
<span class="fc" id="L498">			Map&lt;String, ?&gt; requestArguments = request.getArguments();</span>

<span class="fc" id="L500">			Object value = requestArguments.get(key);</span>
<span class="pc bpc" id="L501" title="3 of 4 branches missed.">			if(value == null &amp;&amp; !requestArguments.containsKey(key)){</span>
<span class="nc" id="L502">				logger.warn(&quot;Evaluation request {} does not specify a group field {}&quot;, request.getId(), key);</span>
			}

<span class="fc" id="L505">			ListMultimap&lt;String, Object&gt; groupedArgumentMap = groupedArguments.get(value);</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">			if(groupedArgumentMap == null){</span>
<span class="fc" id="L507">				groupedArgumentMap = ArrayListMultimap.create();</span>

<span class="fc" id="L509">				groupedArguments.put(value, groupedArgumentMap);</span>
			}

<span class="fc" id="L512">			Collection&lt;? extends Map.Entry&lt;String, ?&gt;&gt; entries = requestArguments.entrySet();</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">			for(Map.Entry&lt;String, ?&gt; entry : entries){</span>
<span class="fc" id="L514">				groupedArgumentMap.put(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L515">			}</span>
<span class="fc" id="L516">		}</span>

		// Only continue with request modification if there is a clear need to do so
<span class="fc bfc" id="L519" title="All 2 branches covered.">		if(groupedArguments.size() == requests.size()){</span>
<span class="fc" id="L520">			return requests;</span>
		}

<span class="fc" id="L523">		List&lt;EvaluationRequest&gt; resultRequests = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L525">		Collection&lt;Map.Entry&lt;Object, ListMultimap&lt;String, Object&gt;&gt;&gt; entries = groupedArguments.entrySet();</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">		for(Map.Entry&lt;Object, ListMultimap&lt;String, Object&gt;&gt; entry : entries){</span>
<span class="fc" id="L527">			Map&lt;String, Object&gt; arguments = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L528">			arguments.putAll((entry.getValue()).asMap());</span>

			// The value of the &quot;group by&quot; column is a single Object, not a Collection (ie. java.util.List) of Objects
<span class="fc" id="L531">			arguments.put(key, entry.getKey());</span>

<span class="fc" id="L533">			EvaluationRequest resultRequest = new EvaluationRequest();</span>
<span class="fc" id="L534">			resultRequest.setArguments(arguments);</span>

<span class="fc" id="L536">			resultRequests.add(resultRequest);</span>
<span class="fc" id="L537">		}</span>

<span class="fc" id="L539">		return resultRequests;</span>
	}

	static
	protected EvaluationResponse evaluate(Evaluator evaluator, EvaluationRequest request){
<span class="fc" id="L544">		logger.info(&quot;Received {}&quot;, request);</span>

<span class="fc" id="L546">		Map&lt;String, ?&gt; requestArguments = request.getArguments();</span>

<span class="fc" id="L548">		EvaluationResponse response = new EvaluationResponse(request.getId());</span>

<span class="fc" id="L550">		Map&lt;FieldName, FieldValue&gt; arguments = new LinkedHashMap&lt;&gt;();</span>

<span class="fc" id="L552">		List&lt;InputField&gt; activeFields = evaluator.getActiveFields();</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">		for(InputField activeField : activeFields){</span>
<span class="fc" id="L554">			FieldName activeName = activeField.getName();</span>

<span class="fc" id="L556">			String key = activeName.getValue();</span>

<span class="fc" id="L558">			Object value = requestArguments.get(key);</span>
<span class="pc bpc" id="L559" title="3 of 4 branches missed.">			if(value == null &amp;&amp; !requestArguments.containsKey(key)){</span>
<span class="nc" id="L560">				logger.warn(&quot;Evaluation request {} does not specify an active field {}&quot;, request.getId(), key);</span>
			}

<span class="fc" id="L563">			FieldValue activeValue = activeField.prepare(value);</span>

<span class="fc" id="L565">			arguments.put(activeName, activeValue);</span>
<span class="fc" id="L566">		}</span>

<span class="fc" id="L568">		logger.debug(&quot;Evaluation request {} has prepared arguments: {}&quot;, request.getId(), arguments);</span>

<span class="fc" id="L570">		Map&lt;FieldName, ?&gt; result = evaluator.evaluate(arguments);</span>

		// Jackson does not support the JSON serialization of &lt;code&gt;null&lt;/code&gt; map keys
<span class="fc" id="L573">		result = replaceNullKey(result);</span>

<span class="fc" id="L575">		logger.debug(&quot;Evaluation response {} has result: {}&quot;, response.getId(), result);</span>

<span class="fc" id="L577">		response.setResult(EvaluatorUtil.decode(result));</span>

<span class="fc" id="L579">		logger.info(&quot;Returned {}&quot;, response);</span>

<span class="fc" id="L581">		return response;</span>
	}

	static
	private &lt;V&gt; Map&lt;FieldName, V&gt; replaceNullKey(Map&lt;FieldName, V&gt; map){

<span class="fc bfc" id="L587" title="All 2 branches covered.">		if(map.containsKey(null)){</span>
<span class="fc" id="L588">			Map&lt;FieldName, V&gt; result = new LinkedHashMap&lt;&gt;(map);</span>
<span class="fc" id="L589">			result.put(ModelResource.DEFAULT_NAME, result.remove(null));</span>

<span class="fc" id="L591">			return result;</span>
		}

<span class="fc" id="L594">		return map;</span>
	}

	static
	private ModelResponse createModelResponse(String id, Model model, boolean expand){
<span class="fc" id="L599">		ModelResponse response = new ModelResponse(id);</span>
<span class="fc" id="L600">		response.setMiningFunction(model.getMiningFunction());</span>
<span class="fc" id="L601">		response.setSummary(model.getSummary());</span>
<span class="fc" id="L602">		response.setProperties(model.getProperties());</span>

<span class="pc bpc" id="L604" title="1 of 2 branches missed.">		if(expand){</span>
<span class="fc" id="L605">			response.setSchema(model.getSchema());</span>
		}

<span class="fc" id="L608">		return response;</span>
	}

<span class="fc" id="L611">	public static final FieldName DEFAULT_NAME = FieldName.create(&quot;_default&quot;);</span>

<span class="fc" id="L613">	private static final Charset CHARSET_UTF8 = Charset.forName(&quot;UTF-8&quot;);</span>

<span class="fc" id="L615">	private static final Logger logger = LoggerFactory.getLogger(ModelResource.class);</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>